---
layout: post
title: 'FizzX: Librería de colisiones para Love2D'
date: '2020-05-18T11:47:00.002-06:00'
author: Deybis A. Melendez Vargas
tags:
- tutorial
- utilidades
- Love2D
- Lua
modified_time: '2020-05-18T11:54:20.638-06:00'
blogger_id: tag:blogger.com,1999:blog-5503112308634825503.post-531461955214420141
blogger_orig_url: https://www.deybismelendez.com/2020/05/fizzx-libreria-de-colisiones-para-love2d.html
---

<div>Love2D tiene un motor de físicas, en realidad es un port de la librería <a href="https://box2d.org/" target="_blank">Box2D</a>. A mi parecer es un como complicado de aplicar y en ocasiones cuando quiero hacer algo mas sencillo ni siquiera lo ocupo, en cambio uso una función simple para detectar colisiones:</div><code class="lua"><pre>local function checkCollision (a, b)<br />    local dx = math.abs(a.x - b.x) -- x distance<br />    local dy = math.abs(a.y - b.y) -- y distance<br />    local mx = a.halfwidth + b.halfwidth -- minimum x distance<br />    local my = a.halfheight + b.halfheight -- minimum y distance<br /><br />    return dx &lt; mx and dy &lt; my<br />end<br /></pre></code><div>Pero en ocasiones puede suceder que necesito una física mínima, no solo saber si dos cajas colisionan y toca implementar la física porteada de Box2D que viene en Love2D.</div><div><br /></div><div>Por suerte, en la web se pueden encontrar muchas librerías de físicas además de la que viene con Love2D, algunas mas complejas y otras mas específicas, y en esta ocasión quiero exponer un poco sobre FizzX.</div><div><br /></div><div><a href="https://bitbucket.org/itraykov/fizzx/src/master/" target="_blank">FizzX</a> es una librería ligera de física al muy estilo de la vieja escuela, esto significa que tenemos lo básico para simular la física de un plataformero clásico.</div><div><br /></div><div>Lo primero que debemos hacer es descargar la librería y colocarla en el proyecto, la importamos de esta manera en el main.lua:</div><code class="lua"><pre>local fizz = require("fizzx.fizz")</pre></code><div>Fizz tiene 3 formas (shape) disponibles, rectangulo ("rect"), circulo ("circ") y línea ("line"), no acepta polígonos ni soporta rotaciones.</div><div><br /></div><div>Al mismo tiempo soporta 3 tipos de cuerpos, static (cuerpo inamovible), kinematic (cuerpo que no colisiona), dynamic (cuerpo que si colisiona).<br /></div><div><br /></div><div>Por ejemplo:</div><code class="lua"><pre>local shape = fizz.addDynamic("rect", 50, 50, 20, 20) --forma, x, y, mitad ancho, mitad alto<br />local shape2 = fizz.addStatic("rect", 200, 200, 30, 100)</pre></code><div>Luego para eliminar una forma de colisión solo hace falta poner fizz.removeShape(shape).</div><div><br /></div><div>Cada forma tiene un callback para las colisiones, es decir, si añadimos la función onCollide() del shape esta será llamada cuando colisione:</div><code class="lua"><pre>function shape.onCollide(a,b,nx,ny,pen) -- self, shape, dirX, dirY,<br />    print(a,b,nx,ny,pen)<br />end</pre></code><div>a es el shape en sí mismo, b es el shape con el que colisionó, nx y ny es la dirección de la colisión, puede ser 0 o 1, es decir, si nx == 0 y ny == 1 entonces la colisión viene desde abajo.</div><div><br /></div><div>A continuación un ejemplo que puedes probar con 2 shapes:</div><code class="lua"><pre>local fizz = require("fizzx.fizz")<br /><br />local shape = fizz.addDynamic("rect", 50, 50, 20, 20)<br />local shape2 = fizz.addStatic("rect", 200, 200, 30, 100)<br /><br />function shape.onCollide(a,b,nx,ny,pen) -- self, shape, dirX, dirY,<br />    print(a,b,nx,ny,pen)<br />end<br /><br />function love.update(dt)<br />    fizz.update(dt)<br />    if love.keyboard.isDown("right") then<br />        shape.xv = 100<br />    elseif love.keyboard.isDown("left") then<br />        shape.xv = -100<br />    else<br />        shape.xv = 0<br />    end<br />    if love.keyboard.isDown("up") then<br />        shape.yv = -100<br />    elseif love.keyboard.isDown("down") then<br />        shape.yv = 100<br />    else<br />        shape.yv = 0<br />    end<br />end<br /><br />function love.draw()<br />    love.graphics.rectangle("fill", shape.x - shape.hw, shape.y - shape.hh, shape.hw*2, shape.hh*2)<br />    love.graphics.rectangle("fill", shape2.x - shape2.hw, shape2.y - shape2.hh, shape2.hw*2, shape2.hh*2)<br />end</pre></code><div>Fizz requiere que actualices en cada frame, por eso necesitas poner fizz.update(dt).<br /></div><div><br /></div><div>shape.xv y shape.xy son las variables de velocity, shape.x, shape.y son las variables de posición, shape.hw, shape.hh son las variables del tamaño del shape, sin embargo estas son las mitades, ya que las formas se dibujan desde el centro, es decir, hw significa half-width y hh half-height.</div><div><br /></div><div>Personalmente me gusta esta librería ya que es muy sencilla aunque con muchas limitaciones, sirve para proyectos sencillos, si quieres saber mas de esta librería revisa el proyecto <a href="https://bitbucket.org/itraykov/fizzx/src/master/" target="_blank">aquí</a>.<br /></div>