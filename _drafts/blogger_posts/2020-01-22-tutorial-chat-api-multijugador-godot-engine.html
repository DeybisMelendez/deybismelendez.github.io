---
layout: post
title: Chat sencillo usando API multijugador en Godot Engine
date: '2020-01-22T16:00:00.000-06:00'
author: Deybis A. Melendez Vargas
tags:
- tutorial
- Godot Engine
- guía
- gdscript
modified_time: '2020-01-24T17:50:52.129-06:00'
thumbnail: https://1.bp.blogspot.com/-9REDZbVWGRQ/XiitNLr9gkI/AAAAAAAABk4/mJWNVjduJO4-_81_l0UHJ3XZCrI6-GqtwCLcBGAsYHQ/s72-c/Captura%2Brealizada%2Bel%2B2020-01-22%2B14.14.21.png
blogger_id: tag:blogger.com,1999:blog-5503112308634825503.post-6028480203461435075
blogger_orig_url: https://www.deybismelendez.com/2020/01/tutorial-chat-api-multijugador-godot-engine.html
---

Últimamente he estado ayudando un poco a Esbva un desarrollador indie que está haciendo un juego de batallas multijugador online. Ésto me ha llevado a por fin aprender a crear juegos multijugador con Godot Engine.<br /><br />Este post no es un tutorial sobre cómo aplicar la API multijugador, si no una pequeña aplicación/ejemplo sobre cómo usarlo. Puedes leer la documentación oficial en este <a href="https://docs.godotengine.org/es/latest/tutorials/networking/high_level_multiplayer.html" target="_blank">link</a> para conocer los aspectos básicos.<br /><br />Aunque sinceramente para mí no fue lo suficientemente clara esa documentación, aunque lo intenta, este artículo está también altamente referenciado por el tutorial de <a href="http://www.narwalengineering.com/2018/07/01/godot-tutorial-simple-chat-room-using-multiplayer-api/" target="_blank">narwalengineering.com</a>.<br /><h2>Estructuración del proyecto </h2><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-9REDZbVWGRQ/XiitNLr9gkI/AAAAAAAABk4/mJWNVjduJO4-_81_l0UHJ3XZCrI6-GqtwCLcBGAsYHQ/s1600/Captura%2Brealizada%2Bel%2B2020-01-22%2B14.14.21.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="750" data-original-width="1134" height="422" src="https://1.bp.blogspot.com/-9REDZbVWGRQ/XiitNLr9gkI/AAAAAAAABk4/mJWNVjduJO4-_81_l0UHJ3XZCrI6-GqtwCLcBGAsYHQ/s640/Captura%2Brealizada%2Bel%2B2020-01-22%2B14.14.21.png" width="640" /></a></div><br />Tal cual se ve en la imagen, una serie de nodos Control, usaremos un TextEdit para presentar el chat (importante activar la propiedad Readonly), y un LineEdit para que el usuario pueda mandar mensajes, estos dos nodos se llaman ChatDisplay y ChatInput respectivamente.<br /><br />Los botones LeaveButton, JoinButton, HostButton, IpEnter para controlar el acceso y hosting del chat, colocamos por defecto el text de IpEnter con la IP 127.0.0.1 que es el equivalente a la IP local de tu pc.<br /><h2>Variables y Señales</h2><br /><pre><code class="gdscript">extends Control<br /><br />const PORT = 3000<br />const MAX_USERS = 4 #not including host<br /><br />onready var chat_display = $RoomUI/ChatDisplay<br />onready var chat_input = $RoomUI/ChatInput&nbsp;<br />func _ready():<br />    chat_input.connect("text_entered", self, "send_message")<br />    get_tree().connect("connected_to_server", self, "enter_room")<br />    get_tree().connect("network_peer_connected", self, "user_entered")<br />    get_tree().connect("network_peer_disconnected", self, "user_exited")<br />    get_tree().connect("server_disconnected", self, "_server_disconnected")<br />    $SetUp/LeaveButton.connect("button_up", self, "leave_room")<br />    $SetUp/JoinButton.connect("button_up", self, "join_room")<br />    $SetUp/HostButton.connect("button_up", self, "host_room")</code></pre>Creo que queda bastante claro cada señal según su nombre, send_message será para enviar mensajes, enter_room se ejecutará cuando un usuario se conecte al servidor, etc...<br /><br /><h2>Inicializando el servidor</h2><br />La función host_room sería la encargada de esto, escribimos lo siguiente:<br /><pre><code class="gdscript">func enter_room():<br />    $SetUp/LeaveButton.show()<br />    $SetUp/JoinButton.hide()<br />    $SetUp/IpEnter.hide()<br />    chat_display.text = "Successfully Joined Room\n"<br />func host_room():<br />    var host = NetworkedMultiplayerENet.new()<br />    host.create_server(PORT, MAX_USERS)<br />    get_tree().set_network_peer(host)<br />    enter_room()<br />    chat_display.text = "Room Created\n"</code></pre>Para iniciar el servidor debemos crear un objeto NetworkedMultiplayerENet y ejecutar el método create_server con él, luego al árbol de escenas (tree) le pasamos esa red con set_network_peer(), ejecutamos enter_room para adaptar los botones y mostrar en el chat lo sucedido.<br /><br /><h2>Conectando al servidor</h2><br />Para que un cliente se conecte al servidor necesitamos lo siguiente:<br /><br /><br /><pre><code class="gdscript">func join_room():<br />    var ip = $SetUp/IpEnter.text<br />    var host = NetworkedMultiplayerENet.new()<br />    host.create_client(ip, PORT)<br />    get_tree().set_network_peer(host)</code></pre>Similar al caso de inicializar el servidor, debemos crear un objeto NetworkedMultiplayerENet, en lugar de create_server, debemos ejecutar create_client y pasar por parámetros la IP del servidor y el puerto de comunicación, luego lo pasamos como parámetro al set_network_peer.<br /><h2></h2><h2>Informando la comunicación</h2><br /><pre><code class="plaintext">func user_entered(id):<br />    chat_display.text += str(id) + " joined the room\n"<br /><br />func user_exited(id):<br />    chat_display.text += str(id) + " left the room\n"<br /><br />func _server_disconnected():<br />    chat_display.text += "Disconnected from Server\n"<br />    leave_room()</code></pre>Las signals que hemos conectado al inicio nos servirán para obtener si alguien se unió, salió o se desconectó del servidor, la id es única por cada usuario conectado, el servidor siempre tendrá el valor 1.<br /><h2>Abandonando el servidor</h2><br /><pre><code class="gdscript">func leave_room():<br />    $SetUp/LeaveButton.hide()<br />    $SetUp/JoinButton.show()<br />    $SetUp/HostButton.show()<br />    $SetUp/IpEnter.show()<br />    chat_display.text += "Left Room\n"<br />    get_tree().set_network_peer(null)</code></pre>No podemos esperar a que el usuario cierre bruscamente el cliente, debemos permitirle poder dejar la sala, lo único que tenemos que hacer es pasar el parámetro null a set_network_peer, lógicamente después de adaptar los botones para que vuelva a su estado inicial.<br /><br /><h2>Enviando y recibiendo mensajes</h2><br />Para enviar mensajes usaremos la signal text_entered conectado a send_message.<br /><br /><pre><code class="gdscript">func send_message(msg):<br />    chat_input.text = ""<br />    var id = get_tree().get_network_unique_id()<br />    rpc("receive_message", id, msg)<br /><br />remotesync func receive_message(id, msg):<br />    chat_display.text += str(id) + ": " + msg + "\n"</code></pre><br />La función rpc (llamadas de procedimiento remoto) es la forma mas sencilla de realizar la comunicación con el servidor, los parámetros son la función a llamar como string, y luego los parámetros que enviaremos a esa función, en este caso id y msg. Recuerda que cada cliente tiene un id único.<br /><br />Por último la función receive_message lleva una palabra clave remotesync al inicio, esto es para indicar a Godot que esa función puede ser llamada de forma remota y con el servidor, ésto por razones de seguridad. En el caso de solo necesitar que la función solo sea llamada remotamente podemos usar la keyword remote.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-oUYgdnd1bf0/XijDk7t0STI/AAAAAAAABlU/G9Kwvyq335Uexo8-SoFyG_Z3aZWwwdWbACLcBGAsYHQ/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2020-01-22%2B15-34-02.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="900" data-original-width="1440" height="400" src="https://1.bp.blogspot.com/-oUYgdnd1bf0/XijDk7t0STI/AAAAAAAABlU/G9Kwvyq335Uexo8-SoFyG_Z3aZWwwdWbACLcBGAsYHQ/s640/Captura%2Bde%2Bpantalla%2Bde%2B2020-01-22%2B15-34-02.png" width="640" /></a></div><br />Si quieres probar el chat basta con exportar y abrirlo dos veces, crear el servidor con uno y conectarse con el otro, como se muestra en la imagen.<br /><br />Si quieres probar conexión local, debes obtener la IP de tu configuración de red, con el comando ipconfig en Windows o ifconfig en Linux puedes ver la información necesaria, yo lo he probado creando el host desde Linux y conectandome desde una PC con Windows y funciona excelente.<br /><br />Te dejo el proyecto de este chat por si lo quieres ojear:&nbsp;<a href="https://github.com/DeybisMelendez/simple-chat-godot/tree/master" target="_blank">Proyecto en Github</a>.<br /><br />Puedes descargar el proyecto exportado a las siguientes plataformas:<br /><br /><a href="https://github.com/DeybisMelendez/simple-chat-godot/releases/download/v1.0.0/win.zip" target="_blank">Windows</a>.<br /><a href="https://github.com/DeybisMelendez/simple-chat-godot/releases/download/v1.0.0/linux.zip" target="_blank">Linux</a>. 