---
layout: post
title: Movimientos de personajes basicos en Godot Engine
date: '2020-01-14T10:12:00.000-06:00'
author: Deybis A. Melendez Vargas
tags:
- tutorial
- Godot Engine
- gdscript
modified_time: '2020-01-14T10:19:09.581-06:00'
thumbnail: https://1.bp.blogspot.com/-PF2IPXAEpKQ/Xh3p0EM02KI/AAAAAAAABfA/DjF_7bNP4CQogioWh3_QMBgXwsAgugE9ACLcBGAsYHQ/s72-c/Captura%2Bde%2Bpantalla%2Bde%2B2020-01-13%2B17-21-38.png
blogger_id: tag:blogger.com,1999:blog-5503112308634825503.post-6148641512807094257
blogger_orig_url: https://www.deybismelendez.com/2020/01/movimientos-basicos-en-godot-engine.html
---

Una de las primeras cosas básicas que queremos hacer cuando iniciamos en el desarrollo de videojuegos, es un personaje simple que se pueda mover, dependiendo de lo que queramos hacer, ya sea un plataformero o un topdown por ejemplo, vamos a necesitar programar el movimiento de diferentes formas, pero en este post vamos a ver cómo hacer los movimientos mas simples posibles, explicado paso a paso.<br /><br />Para realizar estos ejemplos vamos a hacer lo siguiente:<br /><br />Al nodo KinematicBody2D le asignaremos un script y al Sprite le podemos poner el ícono de Godot. El KinematicBody2D requiere un CollisionShape2D y éste require un shape, aunque practicamente no le daremos uso en este ejemplo.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://1.bp.blogspot.com/-PF2IPXAEpKQ/Xh3p0EM02KI/AAAAAAAABfA/DjF_7bNP4CQogioWh3_QMBgXwsAgugE9ACLcBGAsYHQ/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2020-01-13%2B17-21-38.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="185" data-original-width="249" src="https://1.bp.blogspot.com/-PF2IPXAEpKQ/Xh3p0EM02KI/AAAAAAAABfA/DjF_7bNP4CQogioWh3_QMBgXwsAgugE9ACLcBGAsYHQ/s1600/Captura%2Bde%2Bpantalla%2Bde%2B2020-01-13%2B17-21-38.png" /></a></div><br />Nota que si deseas probar estos scripts, al final he dejado un proyecto de ejemplo para que puedas probarlo. <br /><h1>4 Direcciones</h1>El movimiento en 4 direcciones se refiere a que el personaje se puede mover hacia arriba, abajo, izquierda y derecha.<br /><br />Por dar un ejemplo, los juegos topdown, es decir, con vista desde arriba, tienden a tener este tipo de movimiento, como los juegos de Zelda.  El código básico para hacer que se mueva en 4 direcciones es el siguiente:  <br /><pre><code class="swift">extends KinematicBody2D<br />var mov = Vector2.ZERO<br />const SPEED = 300<br />    func _physics_process(_delta):<br />        mov = move_and_slide(mov)<br />        if Input.is_action_pressed("ui_left"):<br />            mov.x = -SPEED<br />            mov.y = 0<br />        elif Input.is_action_pressed("ui_right"):<br />            mov.x = SPEED<br />            mov.y = 0<br />        elif Input.is_action_pressed("ui_up"):<br />            mov.y = -SPEED<br />            mov.x = 0<br />        elif Input.is_action_pressed("ui_down"):<br />            mov.y = SPEED<br />            mov.x = 0<br />        else:<br />            mov = Vector2.ZERO<br /></code></pre><h2>Explicación</h2>La variable mov la declaramos para manejar el movimiento, Vector2 es la clase que sirve para manejar la posición y dirección en Godot, le ponemos .ZERO porque es el equivalente a poner Vector2(0,0), es decir, declarar el mov con valores en cero, ZERO es una constante de Vector2.<br /><br />La constante SPEED es para indicar la velocidad con la que se moverá el personaje.  Dentro del método _physics_process tenemos mov = move_and_slide(mov), esto es porque move_and_slide devuelve la velocidad resultante de moverlo, por ejemplo, si colisiona y se detiene, devolverá Vector2(0,0) por lo que mov pasaría a tener ese valor, es importante hacerlo de esta manera siempre para evitar problemas.<br /><br />A partir de ahí, los if solo se anidan, le asignamos movimiento y detenemos el movimiento según el caso. Al final, en caso de que el usuario no aprete ningún botón, volvemos a asignar mov a sus valores en cero con Vector2.ZERO.  <br /><h1>8 Direcciones</h1>En caso de necesitar que el personaje se pueda mover en 8 direcciones, es decir, las 4 del punto anterior mas sus combinaciones, arriba-derecha, arriba-izquierda, etc.<br /><br />Lo único que necesitamos es variar un poco la estructura de los if del script.  <br /><pre><code class="swift">extends KinematicBody2D<br />    var mov = Vector2.ZERO<br />    const SPEED = 300<br />    func _physics_process(_delta):<br />        mov = move_and_slide(mov)<br />        if Input.is_action_pressed("ui_left"):<br />            mov.x = -SPEED<br />        elif Input.is_action_pressed("ui_right"):<br />            mov.x = SPEED<br />        else:<br />            mov.x = 0<br />        if Input.is_action_pressed("ui_up"):<br />            mov.y = -SPEED<br />        elif Input.is_action_pressed("ui_down"):<br />            mov.y = SPEED<br />        else:<br />            mov.y = 0<br /></code></pre><h2>Explicación</h2>En este ejemplo tenemos 2 if anidados, uno para el eje X, y otro para el eje Y, ambos con un else que pasa el valor a cero si no se está presionando, esto permite mezclar 2 botones, los del eje X son ui_left y ui_right, los del eje Y son ui_up y ui_down.  <br /><h1>Estilo Asteroids o conducción</h1>Este es uno de mis favoritos, recuerdo cuando recién comenzaba y se me hacía super complejo hacer algo como esto, pero no es tanto así, si has jugado Asteroids o similares ya sabes a qué tipo de movimiento me refiero, tener botones para girar izquierda y derecha, uno para avanzar y opcionalmente uno para retroceder, similar a la conducción de un automóvil.  <br /><pre><code class="swift">extends KinematicBody2D<br />var mov = Vector2.ZERO<br />const SPEED = 300<br />const ROT_SPEED = PI<br />var rot = 0<br />func _physics_process(delta):<br />    mov = move_and_slide(mov)<br />    rotation = rot<br />    if Input.is_action_pressed("ui_right"):<br />        rot += ROT_SPEED * delta<br />    elif Input.is_action_pressed("ui_left"):<br />        rot -= ROT_SPEED * delta<br />    if Input.is_action_pressed("ui_up"):<br />        mov = Vector2(cos(rot), sin(rot)) * SPEED<br />    elif Input.is_action_pressed("ui_down"):<br />        mov = Vector2(cos(rot), sin(rot)) * -SPEED<br />    else:<br />        mov = Vector2.ZERO<br /></code></pre><h2>Explicación</h2>Aquí añadimos una variable y una constante nueva que manejan la rotación. ROT_SPEED como lo indica su nombre, es la velocidad con la que va a rotar, le asigno PI para indicarte que la rotación se mide en radianes, es decir, valores entre -Pi a Pi, esto es importante entenderlo para tener siempre una idea de los valores de rotación que asignamos, no confundir con rotation_degrees que es una alternativa a la rotación en grados y no radianes.<br /><br />En el _physics_process agregamos rotation = rot para modificar la rotación del nodo, asi que dependiendo del valor que adquiera rot mostrará la rotación. En lugar de modificar el mov para girar, modificamos el rot, sumando o restando según sea el caso, lo multiplicamos por delta para generalizar el movimiento y que el resultado final no dependa necesariamente de la velocidad de refrescamiento del dispositivo, aunque usemos _physics_process puede suceder que hayan bajones de fps y cambie la velocidad final.<br /><br />Luego tenemos el control de avance y retroceso con ui_up y ui_down respectivamente, aquí es donde modificamos el mov, pero dependiendo del ángulo de rotación (recuerda, en radianes) vamos a obtener el eje x, y a donde apunta, cos() y sin() significa coseno y seno, si manejas un poco de trigonometría entenderás fácilmente el tema.<br /><br />El vector resultante es la dirección del ángulo (rot) con valores flotantes (decimales) que van desde -1 a 1, por esto es que lo multiplicamos por SPEED, para obtener el movimiento necesitado.  <br /><h1>Siguiendo al ratón</h1>Otro tipo de movimiento que solemos buscar es uno donde el personaje se mueva hacia el ratón o algún objeto en particular.  <br /><pre><code class="swift">extends KinematicBody2D<br />var mov = Vector2.ZERO<br />const SPEED = 300<br />func _physics_process(delta):<br />    mov = move_and_slide(mov)<br />    var mouse_pos = get_global_mouse_position()<br />    look_at(mouse_pos)<br />    var dir = mouse_pos - global_position<br />    if Input.is_mouse_button_pressed(BUTTON_LEFT) and dir.length() &gt; 5:<br />        mov = dir.normalized() * SPEED<br />    else:<br />        mov = Vector2.ZERO<br /></code></pre><h2>Explicación</h2>En este caso obtenemos la posición del mouse con get_global_mouse_position, y le pasamos la función look_at() que a como su nombre lo indica rota el objeto en dirección al Vector2 que le pasemos por argumento, en este caso mouse_pos.<br /><br />Luego restamos mouse_pos y global_position para obtener la dirección a la que tiene que ir el personaje, podríamos decir que es restar la posición del objetivo con la posición actual.<br /><br />Luego con el if validamos si el botón izquierdo del mouse está apretado y si el length del vector es mayor que cinco, esto último es necesario para saber qué tan lejos está el personaje del objetivo y evitar que este "se pase" del objetivo, piensalo un poco, el personaje viaja a cierta velocidad y cada frame avanza una cantidad de pixeles, es muy complicado que el personaje caiga exactamente en la posición objetivo, así que es mejor que deje de moverse cuando se acerca lo suficiente, en este caso podríamos decir que 5 pixeles.<br /><br />Entonces asignamos a mov la dirección normalizada, el normalized() es una función que cambia los valores de un vector a su mínima expresión, con valores de -1 a 1, esto para poderlo multiplicar con SPEED y obtener la velocidad deseada.  <br /><h2>Existen mas variaciones de movimiento</h2>Existen muchas formas de mover un personaje u objeto, éstas son las que creo mas comunes y que te pueden interesar, si te interesa que haga mas ejemplos como estos o algún caso en particular, no dudes en dejarme un comentario. <br /><h2>Prueba los scripts</h2><iframe height="600" src="https://deybismelendez.github.io/ejemplos/posts/direcciones/direcciones.html" width="1024"></iframe> 