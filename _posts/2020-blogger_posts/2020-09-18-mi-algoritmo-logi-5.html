---
layout: post
title: Mi algoritmo Logi-5
date: '2020-09-18T13:46:00.000-06:00'
author: Deybis A. Melendez Vargas
tag: programación
modified_time: '2020-09-18T13:46:03.357-06:00'
blogger_id: tag:blogger.com,1999:blog-5503112308634825503.post-8464243640632931019
blogger_orig_url: https://www.deybismelendez.com/2020/09/mi-algoritmo-logi-5.html
---

<p>Este mes de septiembre comenzamos el reto del <a href="https://www.deybismelendez.com/2020/09/reto-programacion-5.html" target="_blank">Logi-5</a>, un reto que trata sobre generar un puzzle derivado del <a href="https://es.wikipedia.org/wiki/Sudoku" target="_blank">sudoku</a>, no es mas que un sudoku de 5x5 con piezas de pentominós como regiones.</p><p>El planteamiento es encontrar un algoritmo que genere puzzles aleatoriamente además de que el jugador pueda verificar su solución.</p><p>En principio suena sencillo de realizar, sin embargo, hay una gran cantidad de combinatorias posibles y hacer el algoritmo sin pensar puede llevarte a callejones sin salida, ya que debes estructurar los números en cada casilla con limitaciones que durante la generación pueden hacer imposible obtener un resultado correcto.</p><h2 style="text-align: left;">Backtracking</h2><p><a href="https://es.wikipedia.org/wiki/Vuelta_atr%C3%A1s" target="_blank">Back tracking</a> es un algorítmo considerado de fuerza bruta que es el método mas común para resolver sudokus. Consiste en utilizar una pila donde vamos almacenando (push) la solución candidata por cada celda y retrocediendo (pop) por cada vez que la solución candidata actual viola una regla, de una manera ordenada podemos conseguir solucionar un sudoku, pero generarlo es otro problema, aunque podemos utilizar el mismo algoritmo, simplemente debemos asignar un valor aleatorio en cada celda, almacenando y retrocediendo hasta obtener un puzzle que contenga todos los requisitos.</p><p><a href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms" target="_blank">Ejemplo de Wikipedia</a>:</p><div class="separator" style="clear: both; text-align: center;"><a href="https://upload.wikimedia.org/wikipedia/commons/8/8c/Sudoku_solved_by_bactracking.gif" style="margin-left: 1em; margin-right: 1em;"><img border="0" data-original-height="297" data-original-width="297" src="https://upload.wikimedia.org/wikipedia/commons/8/8c/Sudoku_solved_by_bactracking.gif" /></a></div><p>Yo ya he utilizado este algoritmo en el pasado, para generar laberintos aleatorios y algo que encontré, es que utilizar un método ordenado puede llevarte a conseguir patrones en tu resultado.</p><p>Por ejemplo, en el caso de aplicar backtracking en generación de laberintos, conseguimos laberintos de un solo pasillo, es decir, que podemos resolver estos laberintos con el truco de la "mano derecha" que consiste en poner tu mano a un lado del muro y seguirlo hasta conseguir salir.</p><p><a href="https://en.wikipedia.org/wiki/Maze_generation_algorithm" target="_blank">Ejemplo de wikipedia</a> usando backtracking para generar laberintos:</p><p></p><div class="separator" style="clear: both; text-align: center;"><object class="BLOG_video_class" contentid="c00ae1a4e295be49" height="266" id="BLOG_video-c00ae1a4e295be49" width="320"></object></div>Esta experiencia pasada me llevó a explorar otras formas de realizar este puzzle y de ahí surgió mi interés por la búsqueda estocástica o algoritmo estocástico.<p></p><h2 style="text-align: left;">Búsqueda estocástica<br /></h2><p>El objetivo de la <a href="https://en.wikipedia.org/wiki/Sudoku_solving_algorithms#Stochastic_search_/_optimization_methods" target="_blank">búsqueda estocástica</a> es utilizar variables aleatorias, es decir, utilizar la aleatoriedad hasta conseguir un resultado válido. Según Wikipedia esto es un método bastante rápido, cosa que no lo creo, considero que es mas rápido utilizar el método anterior, tomando en cuenta que es una matriz de 5x5, que contiene 5 veces números del 1 al 5 y si mi matemática no me falla, entonces estaríamos hablando de un 5! elevado a 5, es decir un total de 24,883,200,000 combinaciones diferentes de las cuales no sé cuantas podrían ser válidas.</p><p>Entonces imagina rellenar en cada ciclo las casillas aleatoriamente hasta obtener un resultado válido, obviamente hay que aplicar una optimización a esto para que funcione.</p><p>Según el artículo en Wikipedia, se puede optimizar reordenando solo las casillas con errores hasta reducirlas a cero, sin embargo, al probar esto, me llevó a callejones sin salida, esto es porque en ocasiones reducía el número de errores hasta 4, sin embargo, ninguna combinación de esos 4 errores lograba un resultado válido, en ocasiones sí lo logra, pero no siempre.</p><h2 style="text-align: left;">Búsqueda estocástica con backtracking</h2><p>Viendome en la situación de encontrarme con callejones sin salida, decidí aplicar una mezcla de ambos métodos, así que el pseudo código en bruto que conseguí fue el siguiente:</p><p><b>rellenar celdas en numeros del 1 al 5 aleatoriamente en cada region.<br /><br />mientras el tablero tenga errores:<br />&nbsp;&nbsp;&nbsp; mezclar errores entre si<br />&nbsp;&nbsp;&nbsp; mientras la configuracion tenga mas errores que al inicio del loop:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; mezclar errores entre si<br />&nbsp;&nbsp;&nbsp; si los nuevos errores son menores que los errores actuales:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; push de configuracion actual a la pila<br />&nbsp;&nbsp;&nbsp; ademas si la pila tiene items:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; pop de configuracion actual<br />&nbsp;&nbsp;&nbsp; si no:<br />&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; rellenar celdas en numeros del 1 al 5 aleatoriamente en cada region</b></p><p>El objetivo aquí fue intentar reducir lo mas posible la cantidad de errores, es por eso, que decidí ordenar aleatoriamente cumpliendo el requisito de las regiones, luego mezclar los errores hasta que los errores sean iguales o menores, es decir, una solución candidata igual o mejor que la anterior, si la nueva configuración es mejor que la anterior (tiene menos errores) entonces lo apilamos, si tiene la misma cantidad de errores, entonces retrocedemos, esto lo hago ya que antes buscamos aleatoriamente una solución candidata igual o mejor, si la pila está vacía, volvemos a rellenar los números igual que al inicio.</p><p>A diferencia de el backtracking no vamos de casilla en casilla, validando una por una, si no que vamos validando en conjunto, reduciendo los errores hasta llegar a cero.</p><p>Considero que el pseudo código requiere una optimización, ya que hay código repetido y probablemente se puede mejorar, pero me conformo con el resultado por ahora.<br /></p>